<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>BerryKV: 基于Bitcask模型的KV存储 | Elitedj's Blog</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script>
<link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.8c77c7521b1f95ec2031c2a79f5c6a698aa4a0dba5ba649dfbc7f73994cddf3f494be6aac7e5724f35cbf72cfde09703.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_180x180_fill_box_center_3.png><meta name=description content="Bitcask起源于Riak 这个分布式数据库，是一个Log-Structured Key Value存储引擎，并且使用Hash Table作为索引。 本文将探索一"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"BerryKV: 基于Bitcask模型的KV存储","item":"/posts/berrykv/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/berrykv/"},"headline":"BerryKV: 基于Bitcask模型的KV存储 | Elitedj\u0027s Blog","datePublished":"2023-04-07T10:57:26+08:00","dateModified":"2023-04-07T10:57:26+08:00","wordCount":3180,"publisher":{"@type":"Person","name":"Elitedj","logo":{"@type":"ImageObject","url":"/images/avatar.png"}},"description":"Bitcask起源于Riak 这个分布式数据库，是一个Log-Structured Key Value存储引擎，并且使用Hash Table作为索引。 本文将探索一"}</script><meta property="og:title" content="BerryKV: 基于Bitcask模型的KV存储 | Elitedj's Blog"><meta property="og:type" content="article"><meta property="og:image" content="/images/avatar.png"><meta property="og:url" content="/posts/berrykv/"><meta property="og:description" content="Bitcask起源于Riak 这个分布式数据库，是一个Log-Structured Key Value存储引擎，并且使用Hash Table作为索引。 本文将探索一"><meta property="og:locale" content="zh"><meta property="og:site_name" content="Elitedj's Blog"><meta property="article:published_time" content="2023-04-07T10:57:26+08:00"><meta property="article:modified_time" content="2023-04-07T10:57:26+08:00"><meta property="article:section" content="posts"><meta property="article:tag" content="Bitcask"><meta property="article:tag" content="Database"><meta property="article:tag" content="KV"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Elitedj's Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>BerryKV: 基于Bitcask模型的KV存储</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2023-04-07</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>7分钟阅读时长</span></div><div class="me-6 my-2"><i class="fas fa-folder me-1"></i>
<a href=/categories/database/ class=hover:text-eureka>Database</a></div></div><p>Bitcask起源于<a href=https://riak.com/>Riak</a> 这个分布式数据库，是一个<code>Log-Structured</code> Key Value存储引擎，并且使用Hash Table作为索引。</p><p>本文将探索一下Bitcask的设计并实现一个简单的基于Bitcask的KV数据库</p><h2 id=架构>架构</h2><p>一个Bitcask实例其实就是一个文件夹，里面有多个data file，就是存储的持久化数据。其中只有一个<code>active data file</code>，表示当前可写入的文件，其余文件都是固定不变的<code>older data file</code>。当一个文件不论什么原因被关闭后，都不再可写，仅可读。</p><p><code>active data file</code>只能采用追加写的方式，顺序写可以减少磁盘寻道时间。每一个KV对写入的格式是固定的，共有6个部分组成。<br><code>crc</code> 循环冗余校验Cyclic Redundancy Check<br><code>tstamp</code> 时间戳<br><code>ksz</code> key的大小<br><code>vsz</code> value的大小<br><code>key</code> key<br><code>val</code> value</p><p>在内存中，维护了一个hash table叫<code>keydir</code>，Bitcask中的每一个key映射到一个固定大小的结构体，这个结构体存储着在data file找到value的关键信息，分别有以下4个部分：<br><code>file_id</code> 存储该key的文件id<br><code>vsz</code> value的大小<br><code>val_pos</code> 文件中的偏移量offset<br><code>tstamp</code> 时间戳</p><div align=center><img src=bitcask.jpg width=70%/></div><h2 id=操作>操作</h2><h3 id=读>读</h3><p>读一个<code>key</code>的值非常的简单，从<code>keydir</code>中获取到对应的结构体，根据<code>file_id</code>得到<code>data file</code>的id，根据<code>val_pos</code>得到这个<code>key</code>对应<code>Entry</code>的偏移量，然后根据对应的<code>ksz</code>和<code>vsz</code>就可以得到<code>value</code>的值了。在大多数情况下，文件系统的<code>read ahead cache</code>会让读操作比预期的快。</p><h3 id=写>写</h3><p>写操作首先将对应的<code>Entry</code>写入到当前的<code>active data file</code>中，并且更新<code>keydir</code>中对应的信息。旧的值依然保留在<code>data file</code>中，在之后的<code>Merge</code>操作会将这些无用的<code>Entry</code>合并掉。</p><h3 id=删除>删除</h3><p>删除是特殊的写操作，只需要写入一个特殊的<code>value</code>值即表明删除了该<code>key</code>，在之后的<code>Merge</code>操作会合并掉已经删除的信息。同时需要将<code>keydir</code>中的索引删除。</p><h3 id=merge>Merge</h3><p>这种简单的模型会造成很多空间上的浪费，<code>data file</code>中会存在很多已经无效的<code>Entry</code>，而<code>Merge</code>操作就是将这些无效的<code>Entry</code>去除的过程。<code>Merge</code>会合并所有<code>older data file</code>成一个或多个<code>data file</code>，其中仅保留仍然有效的<code>key</code>的最新的<code>Entry</code>。</p><p>同时在<code>Merge</code>之后还会为每一个<code>data file</code>生成<code>hint file</code>，里面存储的内容和<code>data file</code>非常像，只是缺少了<code>value</code>。</p><p>当数据库启动时，可以通过扫描<code>hint file</code>来快速构建<code>keydir</code>索引，完成启动。</p><div align=center><img src=Merge.png width=70%/></div><h2 id=berrykv>BerryKV</h2><p><a href=https://github.com/Elitedj/BerryKV>BerryKV</a>是用go实现的Bitcask模型的demo，用于加深对论文的理解。</p><h3 id=model>Model</h3><p>首先我们需要定义一个<code>Berry</code>对象，这个对象包含一个active data file用于写入数据，一个map记录id到older data file的映射关系，一个keydir用于索引。</p><pre><code class=language-go>type Berry struct {
	sync.Mutex
	active *DataFile
	olders map[int32]*DataFile
	keydir KeyDir
}
</code></pre><p><code>DataFile</code>对象是一个log对象的实例，用于读写数据。包含文件id，文件描述符fd，以及当前的文件偏移量offset</p><pre><code class=language-go>type DataFile struct {
	id     int32
	offset int32
	fd     *os.File
}
</code></pre><p>从<code>DataFile</code>中读取或写入时的单位对象叫做<code>Entry</code>，包含了论文中提到的crc、timestamp、keysize、valsize、key以及value。</p><pre><code class=language-go>type Entry struct {
	CheckSum  uint32
	Timestamp uint32
	KeySize   uint32
	ValSize   uint32
	Key       string
	Value     []byte
}
</code></pre><p>keydir是将key和一些元信息进行映射，方便后续查找。</p><pre><code class=language-go>type KeyDir map[string]Meta

type Meta struct {
	FileID      int32
	EntrySize   int32
	EntryOffset int32
	Timestamp   int32
}
</code></pre><h3 id=set操作>Set操作</h3><p><code>Set</code>操作接收一个<code>key</code>和<code>value</code>，并将key和value关联起来。</p><pre><code class=language-go>func (b *Berry) Set(key, val string) error {
	b.Lock()
	defer b.Unlock()

	return b.set(b.active, key, []byte(val))
}
</code></pre><p>根据key和value新生成一个Entry对象，并且写入到active data file中。写入后同步更新keydir中的信息。</p><pre><code class=language-go>func (b *Berry) set(df *DataFile, key string, val []byte) error {
	e := NewEntry(key, val)
	data := e.Encode()

	offset, err := df.Write(data)
	if err != nil {
		return err
	}

	b.keydir[key] = Meta{
		FileID:      int32(df.ID()),
		EntrySize:   int32(len(data)),
		EntryOffset: offset,
		Timestamp:   int32(time.Now().Unix()),
	}
	return nil
}
</code></pre><p>其中<code>Entry.Encode()</code>方法将entry对象编码成二进制字节序列，方便后续写入到文件中。</p><pre><code class=language-go>func (e *Entry) Encode() []byte {
	size := e.Size()
	buf := make([]byte, size)
	binary.LittleEndian.PutUint32(buf[0:4], e.CheckSum)
	binary.LittleEndian.PutUint32(buf[4:8], e.Timestamp)
	binary.LittleEndian.PutUint32(buf[8:12], e.KeySize)
	binary.LittleEndian.PutUint32(buf[12:16], e.ValSize)
	copy(buf[headerSize:headerSize+e.KeySize], []byte(e.Key))
	copy(buf[headerSize+e.KeySize:], e.Value)
	return buf
}
</code></pre><h3 id=get操作>Get操作</h3><p><code>Get</code>操作根据key寻找对应的value值。首先会在keydir中检索是否存在key，存在的话就在key最后写入的data file中读取value值。</p><pre><code class=language-go>func (b *Berry) Get(key string) (string, error) {
	b.Lock()
	defer b.Unlock()

	meta, ok := b.keydir[key]
	if !ok {
		return &quot;&quot;, ErrKeyNotFound
	}

	return b.get(meta)
}

func (b *Berry) get(m Meta) (string, error) {
	fid := m.FileID
	var df *DataFile

	if fid == b.active.ID() {
		df = b.active
	} else {
		_, ok := b.olders[fid]
		if ok {
			df = b.olders[fid]
		}
	}

	if df == nil {
		return &quot;&quot;, ErrDataFileNotFound
	}

	return df.Read(m.EntryOffset, m.EntrySize)
}
</code></pre><p><code>DataFile.Read()</code>根据传入的偏移量和Entry大小读取Entry的值，并且解码，从中获取value值。Entry在解码过程中会校验crc值是否正确。</p><pre><code class=language-go>func (df *DataFile) Read(offset, size int32) (string, error) {
	buf := make([]byte, size)

	_, err := df.fd.ReadAt(buf, int64(offset))
	if err != nil &amp;&amp; err != io.EOF {
		return &quot;&quot;, err
	}

	e := &amp;Entry{}
	err = e.Decode(buf)
	if err != nil {
		return &quot;&quot;, err
	}

	return string(e.Value), nil
}

func (e *Entry) Decode(buf []byte) error {
	n := len(buf)
	if n &lt; headerSize {
		return ErrEntryIllegal
	}

	e.CheckSum = binary.LittleEndian.Uint32(buf[0:4])
	e.Timestamp = binary.LittleEndian.Uint32(buf[4:8])
	e.KeySize = binary.LittleEndian.Uint32(buf[8:12])
	e.ValSize = binary.LittleEndian.Uint32(buf[12:16])

	if n != int(headerSize+e.KeySize+e.ValSize) {
		return ErrEntryIllegal
	}

	e.Key = string(buf[headerSize : headerSize+e.KeySize])
	e.Value = make([]byte, e.ValSize)
	copy(e.Value, buf[headerSize+e.KeySize:])
	crc := crc32.ChecksumIEEE(e.Value)
	if crc != e.CheckSum {
		return ErrCrcFail
	}
	return nil
}
</code></pre><h3 id=del操作>Del操作</h3><p><code>Del</code>操作是特殊的<code>Set</code>操作，通过写入一个特殊值表示该key被删除，同时删除掉keydir中的索引。</p><pre><code class=language-go>func (b *Berry) Del(key string) error {
	b.Lock()
	defer b.Unlock()

	_, ok := b.keydir[key]
	if !ok {
		return nil
	}

	return b.del(key)
}

func (b *Berry) del(key string) error {
	e := NewEntry(key, []byte(SpecialVal))
	data := e.Encode()

	_, err := b.active.Write(data)
	if err != nil {
		return err
	}

	delete(b.keydir, key)

	return nil
}
</code></pre><h3 id=merge-1>Merge</h3><p><code>Merge</code>是删除过期Entry来压缩data file文件的操作，减少磁盘空间的消耗。触发<code>Merge</code>操作有很多的策略和方法，<code>BerryKV</code>采用了最简单的定时触发，只要到达一定时间就进行一次Merge操作。</p><p>Merge操作除了压缩data file外，还会生成一个<code>Hint File</code>用于记录keydir中的信息，方便db启动是快速创建keydir。</p><pre><code class=language-go>func (b *Berry) Merge(d time.Duration) {
	ticker := time.NewTicker(d).C

	for range ticker {
		b.Lock()
		b.merge()
		b.makeHintFile()
		b.Unlock()
	}
}
</code></pre><p>首先来关注一下<code>Berry.merge()</code>操作。该操作先创建了一个新的active data file，并将keydir中所有的key对应的value信息写入到新的active中，并且关闭当前的active和所有的olders，然后删除掉所有的data file文件，并将新的active文件替换老的active文件，后续所有的Entry都写入到该active中。</p><pre><code class=language-go>func (b *Berry) merge() error {
	// make a temp datafile
	tmpDir, err := os.MkdirTemp(&quot;&quot;, &quot;merge&quot;)
	if err != nil {
		return err
	}
	defer os.RemoveAll(tmpDir)

	mdf, err := NewDataFile(tmpDir, 0)
	if err != nil {
		return err
	}

	// rewrite k-v into temp datafile
	for k := range b.keydir {
		v, _ := b.get(b.keydir[k])
		b.set(mdf, k, []byte(v))
	}

	// close active
	b.active.Close()

	// close all olders
	for _, df := range b.olders {
		df.Close()
	}

	b.olders = make(map[int32]*DataFile)

	// remove all datafile
	filepath.Walk(DataDir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if filepath.Ext(path) == &quot;.db&quot; {
			err := os.Remove(path)
			if err != nil {
				return err
			}
		}
		return nil
	})

	// replace active datafile
	os.Rename(filepath.Join(tmpDir, fmt.Sprintf(DataFileNameFormat, 0)),
		filepath.Join(DataDir, fmt.Sprintf(DataFileNameFormat, 0)))

	b.active = mdf

	return nil
}
</code></pre><p>创建hint file就是将keydir序列化到文件中。</p><pre><code class=language-go>func (b *Berry) makeHintFile() error {
	path := filepath.Join(DataDir, HintFile)
	err := b.keydir.Encode(path)
	if err != nil {
		return err
	}

	return nil
}

func (k *KeyDir) Encode(path string) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := gob.NewEncoder(file)
	err = encoder.Encode(k)
	if err != nil {
		return err
	}

	return nil
}
</code></pre><h3 id=check-active-file-size>Check active file size</h3><p>当active file的大小超过了文件的最大限制时，将当前active变成只读的older file，并新建一个active文件进行新的写入。</p><p>为了方便实现，这个操作也是定时触发检查。</p><pre><code class=language-go>func (b *Berry) CheckActiveFileSize(d time.Duration) {
	ticker := time.NewTicker(d).C

	for range ticker {
		b.checkActiveFileSize()
	}
}

func (b *Berry) checkActiveFileSize() error {
	b.Lock()
	defer b.Unlock()

	stat, err := b.active.fd.Stat()
	if err != nil {
		return err
	}

	size := stat.Size()
	if size &lt; MaxDataFileSize {
		return nil
	}

	id := b.active.ID()
	b.olders[id] = b.active

	df, err := NewDataFile(DataDir, id+1)
	if err != nil {
		return err
	}

	b.active = df

	return nil
}
</code></pre><h3 id=启动db>启动DB</h3><p>当data file不论什么原因被关闭后，都会变成只读状态的older data file，所以db启动的时候，会先去把所有的data file都加载成到olders中，并生成一个新的data file作为active。如果有hint file存在，则解析hint file用于构建keydir。完成加载之后，创建两个协程定时进行Merge操作和Check File Size操作。</p><pre><code class=language-go>func New() (*Berry, error) {
	var maxID int32 = 0
	olders := make(map[int32]*DataFile)

	// get all datafiles
	files, err := filepath.Glob(fmt.Sprintf(&quot;%s/*.db&quot;, DataDir))
	if err != nil {
		return nil, err
	}

	for _, file := range files {
		filename := filepath.Base(file)
		id, err := strconv.ParseInt(strings.TrimPrefix(strings.TrimSuffix(filename, &quot;.db&quot;), &quot;berry_&quot;), 10, 32)
		if err != nil {
			return nil, err
		}

		fd, err := os.Open(file)
		if err != nil {
			return nil, err
		}

		stat, err := fd.Stat()
		if err != nil {
			return nil, err
		}

		df := &amp;DataFile{
			id:     int32(id),
			fd:     fd,
			offset: int32(stat.Size()),
		}

		olders[int32(id)] = df

		if int32(id) &gt; maxID {
			maxID = int32(id)
		}
	}

	activeDF, err := NewDataFile(DataDir, maxID+1)
	if err != nil {
		return nil, err
	}

	keydir := make(KeyDir)

	// check if a hint file already
	hintFile := filepath.Join(DataDir, HintFile)
	_, err = os.Stat(hintFile)
	if err == nil {
		keydir.Decode(hintFile)
	}

	b := &amp;Berry{
		active: activeDF,
		olders: olders,
		keydir: keydir,
	}

	go b.CheckActiveFileSize(defaultCheckFileSizeInterval)

	go b.Merge(defaultMergeInterval)

	return b, nil
}
</code></pre><h2 id=参考>参考</h2><p><a href=https://github.com/basho/bitcask>github bitcask</a><br><a href=https://riak.com/assets/bitcask-intro.pdf>bitcask paper</a></p></article><div class=my-4><a href=/tags/bitcask/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#Bitcask</a>
<a href=/tags/database/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#Database</a>
<a href=/tags/kv/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#KV</a></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/posts/ai-draw/ class=block>做一个AI绘画魔法师</a></div></div><div id=valine-comments class=mt-4></div><script defer src=https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js integrity=sha384-e0+DNUCJo75aOAzHQbFWYBCM9/S4f0BhRJXvEgbE3mMS85RM20MSSGStHuNdY2QK crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){new Valine({el:"#valine-comments",appId:"zOEvCRaHczqQkvn7g5bk2d9c-gzGzoHsz",appKey:"JJQvXVH4XIDyjJaIK2HWeTY3"})})</script></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2019 - 2023 <a href=https://github.com/Elitedj>Elitedj</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>