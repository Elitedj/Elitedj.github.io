<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[c/c++]关于输入输出 | Elitedj's Blog</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script>
<link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.a975d08212c5439f29e6074e7ad58e159ae1ef5efb6a31962fa3b6885557e794dd9315f4a8a16d705066d023f4eaaf07.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_180x180_fill_box_center_3.png><meta name=description content="Elitedj's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"[c/c++]关于输入输出","item":"/posts/c-io/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/c-io/"},"headline":"[c\/c\u002b\u002b]关于输入输出 | Elitedj\u0027s Blog","datePublished":"2019-05-08T16:16:53+00:00","dateModified":"2019-05-08T16:16:53+00:00","wordCount":3243,"publisher":{"@type":"Person","name":"Elitedj","logo":{"@type":"ImageObject","url":"/images/avatar.png"}},"description":"Elitedj\u0027s Blog"}</script><meta property="og:title" content="[c/c++]关于输入输出 | Elitedj's Blog"><meta property="og:type" content="article"><meta property="og:image" content="/images/avatar.png"><meta property="og:url" content="/posts/c-io/"><meta property="og:description" content><meta property="og:locale" content="zh"><meta property="og:site_name" content="Elitedj's Blog"><meta property="article:published_time" content="2019-05-08T16:16:53+00:00"><meta property="article:modified_time" content="2019-05-08T16:16:53+00:00"><meta property="article:section" content="posts"><meta property="article:tag" content="C/C++"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Elitedj's Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>[c/c++]关于输入输出</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2019-05-08</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>7分钟阅读时长</span></div><div class="me-6 my-2"><i class="fas fa-folder me-1"></i>
<a href=/categories/c/c++/ class=hover:text-eureka>C/C++</a></div></div><p>这篇文章很久之前就想写了，可是一直都很忙，现在终于可以开始慢慢的写啦～</p><p>因为拿到了GDCPC的名额，所以在4.19晚上打了一场双鸭山大学的ACM校赛重现赛，先来看一道水题吧</p><p><img src=timu.jpg alt=timu></p><p>题目的意思非常的简单，就是输入一串数字，让你判断是否有3个数字能够构成三角形。我们很小的时候就知道三角形满足两边之和大于第三边，所以很快就能够想到一个算法来解这一题。</p><pre><code class=language-c++>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int num[100005];

int main()
{
    int n,flag=0;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;num[i];
    sort(num+1, num+n+1);
    for(int i=n-2;i&gt;=1;i--)
    {
        if(num[i]+num[i+1]&gt;num[i+2])
        {
            flag=1;
            break;
        }
    }
    if(flag)
        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
    else
        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    return 0;
}
</code></pre><p>这个算法肯定是正确的，也是当时我们想到的最好的算法了（不过题解并不是如此，后面会给出题解），于是我们就提交了一发。</p><p><strong>TLE！！！</strong></p><p>超时，这个算法的复杂度达到了O(nlogn)，被卡了时间，因为我们当时实在想不出更好的算法，并且这一题非常多人A了，所以我们就瞎j8改代码，疯狂的测试。</p><pre><code class=language-c++>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;

int num[100005];

int main()
{
    int n,flag=0;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;, &amp;num[i]);
    sort(num+1, num+n+1);
    for(int i=n-2;i&gt;=1;i--)
    {
        if(num[i]+num[i+1]&gt;num[i+2])
        {
            flag=1;
            break;
        }
    }
    if(flag)
        printf(&quot;YES\n&quot;);
    else
        printf(&quot;NO\n&quot;);
    return 0;
}
</code></pre><p>还是继续TLE！！！我们再来看一个代码，和第一个很类似，就多了一行而已！</p><pre><code class=language-c++>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int num[100005];

int main()
{
    ios::sync_with_stdio(false);
    int n,flag=0;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;num[i];
    sort(num+1, num+n+1);
    for(int i=n-2;i&gt;=1;i--)
    {
        if(num[i]+num[i+1]&gt;num[i+2])
        {
            flag=1;
            break;
        }
    }
    if(flag)
        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
    else
        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    return 0;
}
</code></pre><p>感动天感动地的AC终于出现了！！！</p><p><img src=bqb.jpg alt=bqb></p><p>那么 <strong>ios::sync_with_stdio(false)</strong> 究竟有什么用呢？<br>从函数的名字来看是关闭和stdio的同步，并且关闭同步后输入输出的速度快了不少，使我们成功AC了这一题。</p><p>其实这题的正确姿势是这样的，若一串数列不能找出三个数字组成一个三角形，那么它们必定没有三个数能够满足两边之和大于第三边，再想一想斐波那契数列，如果你之前看到这个题目没有想到斐波那契数列的话，看到这应该会有一种恍然大悟的感觉，并且数列中的每一个数字是不大于2^31-1的，而斐波那契数列的第47项就已经大于这个范围了，也就是说，当数列的长度大于等于47，那么它们肯定有三个数字能够构成三角形。</p><p>当数列长度小于47时，就用排序加遍历的方法判断，当数列长度大于等于47时，直接输出YES即可。</p><p>很明显这一题的数据就是卡将数列排序再遍历一次的算法，然而却被我们用小技巧AC了。</p><p>虽然AC了，但是我对c/c++的输入输出产生了兴趣，以前我从来都没有想过输入输出的实现方法和它们之间的区别，从那一晚起我就想要寻找到我想要的答案并且下这一篇blog，然而之后的一段时间事情实在太多，一拖再拖，到现在终于有点时间了。</p><h2 id=stream>Stream</h2><p><strong>stream</strong>，也就是大家熟知的流，什么是流呢？我在<strong>stdio.h</strong>文档找到了以下的一段介绍</p><blockquote><p>This library uses what are called streams to operate with physical devices such as keyboards, printers, terminals or with any other type of files supported by the system. Streams are an abstraction to interact with these in an uniform way; All streams have similar properties independently of the individual characteristics of the physical media they are associated with.</p></blockquote><p>我还在一本书上找到下面的一段介绍</p><blockquote><p>  Input and output, whether to or from physical devices such as terminals and tape drives, or whether to or from files supported on structured storage devices, are mapped into logical data streams, whose properties are more uniform than their various inputs and outputs. Two forms of mapping are supported: text streams and binary streams.<br>  A text stream consists of one or more lines. A line in a text stream consists of zero or more characters plus a terminating new-line character. (The only exception is that in some implementations the last line of a file does not require a terminating new-line character.) Unix adopted a standard internal format for all text streams. Each line of text is terminated by a new-line character. That&rsquo;s what any program expects when it reads text, and that&rsquo;s what any program produces when it writes text. (This is the most basic convention, and if it doesn&rsquo;t meet the needs of a text-oriented peripheral attached to a Unix machine, then the fix-up occurs out at the edges of the system. Nothing in between needs to change.) The string of characters that go into, or come out of a text stream may have to be modified to conform to specific conventions. This results in a possible difference between the data that go into a text stream and the data that come out. For instance, in some implementations when a space-character precedes a new-line character in the input, the space character gets removed out of the output. In general, when the data only consists of printable characters and control characters like horizontal tab and new-line, the input and output of a text stream are equal.<br>  Compared to a text stream, a binary stream is pretty straight forward. A binary stream is an ordered sequence of characters that can transparently record internal data. Data written to a binary stream shall always equal the data that gets read out under the same implementation. Binary streams, however, may have an implementation-defined number of null characters appended to the end of the stream. There are no further conventions which need to be considered.<br>  Nothing in Unix prevents the program from writing arbitrary 8-bit binary codes to any open file, or reading them back unchanged from an adequate repository. Thus, Unix obliterated the long-standing distinction between text streams and binary streams.</p></blockquote><p>同时我在这本书中还发现了这两段话</p><blockquote><p>  When a C program starts its execution the program automatically opens three standard streams named <strong>stdin</strong>, <strong>stdout</strong>, and <strong>stderr</strong>. These are attached for every C program.<br>  The first standard stream is used for input buffering and the other two are used for output. These streams are sequences of bytes.</p></blockquote><p>每一个c程序都会打开<strong>stdin</strong>、<strong>stout</strong>和<strong>stderr</strong>这三个流，第一个用于输入，后两个用于输出，最后那个是用于输出错误信息的。最重要的是最后那一句话<strong>These streams are sequences of bytes.</strong> 这些流是字节串。</p><p><img src=stream.png alt=stream></p><p>流其实是一个比较抽象的概念，因为输入设备和输出设备非常的多样化，所以c为了统一输入输出的方式，提出了流的概念，按照我通俗的理解，CPU是一个大工厂，而I/O设备就是运送原材料的大货车，大货车将车上的货物一件件的交到大工厂，一件件的货物就是流。</p><h2 id=buffer>Buffer</h2><p>我在c/c++的文档中找到了对<strong>Buffer</strong>的定义</p><blockquote><p>A buffer is a block of memory where data is accumulated before being physically read or written to the associated file or device. Streams can be either fully buffered, line buffered or unbuffered. On fully buffered streams, data is read/written when the buffer is filled, on line buffered streams this happens when a new-line character is encountered, and on unbuffered streams characters are intended to be read/written as soon as possible.</p></blockquote><p>Buffer翻译过来的话就是缓冲区，根据输入和输出，缓冲区可以分为输入缓冲和输出缓冲，它其实就是一块内存而已，输入缓冲区用来暂存从外设输入进来的内容，输出缓冲区就是用来暂存要输出在外设的内容。</p><p>为什么我们需要缓冲区这种东西呢？主要是为了解决低速的I/O设备与高速的CPU速度不匹配的问题，想象一下大工厂(CPU)里的工人需要在门口等待大货车(I/O设备)送货进来，而大货车是比较慢的，工人们其实可以去做别的事情，而不需要苦苦等待浪费时间，为了解决这种CPU利用率低的情况，我们引入了缓冲区，把缓冲区想象成传送带，工人不需要一直在门口等待货车送货进来，大货车将货物放到传送带上即可。</p><p>并且流分为<strong>全缓冲</strong>、<strong>行缓冲</strong>和<strong>不缓冲</strong>三种。<br><strong>全缓冲</strong><br>等到缓冲区满了以后才执行真正的I/O操作</p><p><strong>行缓冲</strong><br>遇到换行符执行真正的I/O操作</p><p><strong>不缓冲</strong>
顾名思义就是不进行缓冲，比如<strong>stderr</strong>，需要立刻输出信息</p><h2 id=测试cc标准输入输出的速度>测试C/C++标准输入输出的速度</h2><p>scanf/cin和printf/cout都是带缓冲的，当调用scanf/cin时，它们会先去看看缓冲区有没有数据，若有的话会先从缓冲区读入，若缓冲区空的话，就会等待输入，printf/cout同理</p><p>为了测试scanf和cin、printf和cout之间速度的差异，我在自己的笔记本上做了一个小实验，我的系统环境是ubuntu18.04，不同的系统和配置都可能产生不同的结果。</p><h3 id=生成测试数据>生成测试数据</h3><p>为了测试scanf和cin，肯定得有输入数据才行，我生成了1000000行1111111111111111的文本文件来测试</p><pre><code class=language-shell>$ yes 1111111111111111 | head -1000000 &gt; data.txt
</code></pre><h3 id=scanf-vs-cin>scanf vs cin</h3><p>测试文件分别如下</p><pre><code class=language-c++>//testcin.cpp
#include&lt;iostream&gt;
using namespace std;

int main()
{
    char buffer[16];
    while(cin&gt;&gt;buffer)
        ;
    return 0;
}
</code></pre><pre><code class=language-c++>//testscanf.cpp
#include&lt;stdio.h&gt;
int main()
{
    char buffer[16];
    while(scanf(&quot;%s&quot;, buffer)!=EOF)
        ;
    return 0;
}
</code></pre><p>编译</p><pre><code class=language-shell>$ g++ testcin.cpp -o testcin.out
$ g++ testscanf.cpp -o testscanf.out
</code></pre><p>运行</p><pre><code class=language-shell>$ time ./testcin.out &lt; data.txt
$ time ./testscanf.out &lt; data.txt
</code></pre><p>结果如下
<img src=scanf&cin.png alt=scanf&cin></p><p>很明显scanf比cin快很多</p><p>我又测试了一下关闭同步的cin的速度，测试代码如下</p><pre><code class=language-c++>//testcin.cpp
#include&lt;iostream&gt;
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    char buffer[16];
    while(cin&gt;&gt;buffer)
        ;
    return 0;
}
</code></pre><p>测试结果如下
<img src=cin_without_sync.png alt=cin_without_sync></p><p>可以看到关闭同步的cin和scanf速度差不多，这是因为C++为了兼容C，使得scanf和cin可以同时使用，所以让cin和scanf保持同步，这就使得cin花了一些时间在处理同步上。当使用cin而不使用scanf时，可以关闭同步来提高cin的速度，若在混用scanf和cin时关闭了同步，就可能会导致一些错乱，不建议这么做。</p><p>我在网上找到了别人在不同的系统和编译器环境下测试的结果，测试数据是55MB的文件。</p><p><img src=input_summery.png alt=input_summery></p><h3 id=printf-vs-cout>printf vs cout</h3><p>其实输出和输入差不多，不过也做个简单的测试吧</p><pre><code class=language-c++>//testprintf.cpp
#include&lt;stdio.h&gt;

int main()
{
    int n = 1000000;
    while(n--)
        printf(&quot;1&quot;);
       return 0;
}
</code></pre><pre><code class=language-c++>//testcout.cpp
#include&lt;iostream&gt;
using namespace std;

int main()
{
    int n = 1000000;
    while(n--)
        cout&lt;&lt;&quot;1&quot;;
       return 0;
}
</code></pre><p>编译</p><pre><code class=language-shell>$ g++ testprintf.cpp -o testprintf.out
$ g++ testcout.cpp -o testcout.out
</code></pre><p>运行</p><pre><code class=language-shell>$ time ./testprintf.out &gt; print.txt
$ time ./testcout.out &gt; cout.txt
</code></pre><p>结果如下</p><p><img src=printf&cout.png alt=printf&cout></p><p>关闭同步再测试一次</p><pre><code class=language-c++>//testcout.cpp
#include&lt;iostream&gt;
using namespace std;

int main()
{
    ios::sync_with_stdio(flase);
    int n = 1000000;
    while(n--)
        cout&lt;&lt;&quot;1&quot;;
       return 0;
}
</code></pre><p>结果如下</p><p><img src=cout_without_sync.png alt=cout_without_sync></p><p>同样，关闭同步后速度更快了，原理和输入是一样的。</p><p>如果在关闭同步后混用printf和cout的话，可能会导致输出的顺序错乱，不过我试了几次都没成功。</p><h2 id=算法竞赛的奇技淫巧快读快写>算法竞赛的奇技淫巧——快读快写</h2><p>其实在算法竞赛当中早就有比scanf/cin和printf/cout更快的奇技淫巧了（我也是这次写博文查资料才知道的，真是太菜了），称为快读和快写，据测试比scanf/printf和关闭同步的cin/cout更加快</p><pre><code class=language-c++>//针对正负整数的快读快写
inline int Quick_Read(){
    int s = 0,w = 1;
    char ch = getchar();
    while (ch &lt;= '0' || ch &gt; '9'){
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0' , ch = getchar();
    return s * w;
}

inline void Quick_Write(int x){
  if (x &lt; 0){
    putchar('-');
    re = -re;
  }
  if (x &gt; 9) Quick_Write(x/10);
  putchar(x%10 + '0');
}
</code></pre><p>快读快写终究只是小技巧，降低算法的复杂度才是王道！（留下了没技术的眼泪.jpg）<br>溜了溜了～</p></article><div class=my-4><a href=/tags/c/c++/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#C/C++</a></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">上一页</span>
<a href=/posts/2019gdcpc/ class=block>[2019GDCPC]柠檬精的双鸭山大学两日游</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/posts/cccc/ class=block>【总结】关于第十届蓝桥杯和第四届CCCC字符串大赛的体验</a></div></div><div id=valine-comments class=mt-4></div><script defer src=https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js integrity=sha384-e0+DNUCJo75aOAzHQbFWYBCM9/S4f0BhRJXvEgbE3mMS85RM20MSSGStHuNdY2QK crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){new Valine({el:"#valine-comments",appId:"zOEvCRaHczqQkvn7g5bk2d9c-gzGzoHsz",appKey:"JJQvXVH4XIDyjJaIK2HWeTY3"})})</script></div><div class=col-span-2><div class="bg-primary-bg
prose sticky top-16 z-10 hidden px-6 py-4 lg:block"><h3>本页内容</h3></div><div class="sticky-toc hidden px-6 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#stream>Stream</a></li><li><a href=#buffer>Buffer</a></li><li><a href=#测试cc标准输入输出的速度>测试C/C++标准输入输出的速度</a><ul><li><a href=#生成测试数据>生成测试数据</a></li><li><a href=#scanf-vs-cin>scanf vs cin</a></li><li><a href=#printf-vs-cout>printf vs cout</a></li></ul></li><li><a href=#算法竞赛的奇技淫巧快读快写>算法竞赛的奇技淫巧——快读快写</a></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2019 - 2022 <a href=https://github.com/Elitedj>Elitedj</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>