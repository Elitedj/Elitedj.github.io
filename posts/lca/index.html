<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[LCA]最近公共祖先 | Elitedj's Blog</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script>
<link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.a975d08212c5439f29e6074e7ad58e159ae1ef5efb6a31962fa3b6885557e794dd9315f4a8a16d705066d023f4eaaf07.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_180x180_fill_box_center_3.png><meta name=description content="Elitedj's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"[LCA]最近公共祖先","item":"/posts/lca/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/lca/"},"headline":"[LCA]最近公共祖先 | Elitedj\u0027s Blog","datePublished":"2019-09-03T20:30:14+00:00","dateModified":"2019-09-03T20:30:14+00:00","wordCount":4079,"publisher":{"@type":"Person","name":"Elitedj","logo":{"@type":"ImageObject","url":"/images/avatar.png"}},"description":"Elitedj\u0027s Blog"}</script><meta property="og:title" content="[LCA]最近公共祖先 | Elitedj's Blog"><meta property="og:type" content="article"><meta property="og:image" content="/images/avatar.png"><meta property="og:url" content="/posts/lca/"><meta property="og:description" content><meta property="og:locale" content="zh"><meta property="og:site_name" content="Elitedj's Blog"><meta property="article:published_time" content="2019-09-03T20:30:14+00:00"><meta property="article:modified_time" content="2019-09-03T20:30:14+00:00"><meta property="article:section" content="posts"><meta property="article:tag" content="Algorithm"><meta property="og:see_also" content="/posts/persistent-seg-tree/"><meta property="og:see_also" content="/posts/shortest-path/"><meta property="og:see_also" content="/posts/seg-tree/"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Elitedj's Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>[LCA]最近公共祖先</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2019-09-03</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>9分钟阅读时长</span></div><div class="me-6 my-2"><i class="fas fa-folder me-1"></i>
<a href=/categories/algorithm/ class=hover:text-eureka>Algorithm</a></div></div><h2 id=前言>前言</h2><p>LCA(Least Common Ancestors)，即最近公共祖先，是指在有根树中，某两个顶点U和V的最近公共祖先。</p><p><img src=s.png alt=s></p><p>例如这一刻有根树，LCA(2, 3)是1，LCA(6, 9)是3。<br>这一篇blog会介绍3种如何寻找LCA的算法。</p><h2 id=tarjan>Tarjan</h2><p>Tarjan(Robert Endre Tarjan)是一位著名的计算机科学家，曾在1986年获得Turing奖。一般提到Tarjan算法都会先想到强连通分量的那一个算法，但是Tarjan也发明了一个算法求解LCA问题。</p><p>要理解这一个算法需要先学会<strong>并查集</strong>，不然的话可能会有一点的小问题。Tarjan算法是强制离线的，也就是要先把所有的询问都存起来，然后再一起求解，不能边询问边回答。</p><p>Tarjan算法利用了<strong>DFS</strong>和<strong>并查集</strong>一起求解。</p><p>DFS中主要做了以下几件事情：</p><ul><li>标记自己已访问（可以用一个vis数组标记）</li><li>在并查集中把自己作为自己的父节点，即fa[rt]=rt</li><li>DFS所有的儿子节点，并在DFS结束后将儿子结点在并查集中的指向自身，即fa[son]=rt</li><li>处理和自身有关的询问，若另一个顶点在并查集中的指向不为-1(初始化时将并查集所有的结点设为-1)，则LCA(rt, other)就为fa[other]</li></ul><p>好像干说也不知道是怎么一回事，还是看图直接一点。</p><p>就用这一颗树来做例子吧，我们分别要求LCA(2, 4)、LCA(6, 9)和LCA(6, 8)。</p><p><img src=s.png alt=s></p><p>将fa数组初始化为-1</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td></tr></tbody></table><p>DFS从1开始，fa[1]=1</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td></tr></tbody></table><p>然后遍历1的儿子顶点2，fa[2]=2</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td></tr></tbody></table><p>然后遍历2的儿子顶点4，fa[4]=4</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>4</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td></tr></tbody></table><p>这时候4没有儿子顶点了，所以要开始处理与4有关的询问，之前我们说过要求LCA(4, 2)，这时候fa[2]!=-1,所以LCA(4, 2)=fa[2]=2,然后将4的父亲改为2,fa[4]=2</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td></tr></tbody></table><p><img src=1.png alt=1></p><p>继续遍历2的儿子顶点5，fa[5]=5</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>2</td><td style=text-align:center>5</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td></tr></tbody></table><p>继续遍历5的儿子顶点8，fa[8]=8</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>2</td><td style=text-align:center>5</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>8</td><td style=text-align:center>-1</td></tr></tbody></table><p>然后开始处理关于8的询问，LCA(6, 8)，因为fa[6]=-1，所以我们先暂时不管，等遍历到6时再处理这一个询问，将顶点8的父亲改为5,fa[8]=5</p><p>然后回到顶点5，处理关于5的询问，没有，将顶点5的父亲改为2，回退到2</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>-1</td><td style=text-align:center>-1</td><td style=text-align:center>5</td><td style=text-align:center>-1</td></tr></tbody></table><p><img src=2.png alt=2></p><p>回退到顶点1，将fa[2]改为1</p><p><img src=3.png alt=3></p><p>然后继续遍历顶点3，然后到顶点6，这里和上面的修改一样，偷懒省略一点点</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>6</td><td style=text-align:center>-1</td><td style=text-align:center>5</td><td style=text-align:center>-1</td></tr></tbody></table><p>开始处理关于6的询问，求LCA(6, 8)，因为fa[8]！=-1,然后就根据并查集的思想去找8的根节点，找到是1，所以LCA(6, 8)=1。求LCA(6, 9)时，因为fa[9]=-1，所以先暂时不管。将顶点6的父亲改为3，回退到3</p><p><img src=4.png alt=4></p><p>继续遍历到顶点7然后到顶点9</p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>3</td><td style=text-align:center>7</td><td style=text-align:center>5</td><td style=text-align:center>9</td></tr></tbody></table><p>然后处理关于9的询问，求LCA(6, 9)，找到6这时候的祖先为3，所以LCA(6, 9)=3，然后回退到7回退到3</p><p><img src=5.png alt=5></p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>3</td><td style=text-align:center>3</td><td style=text-align:center>5</td><td style=text-align:center>7</td></tr></tbody></table><p>最后回退到1，结束</p><p><img src=6.png alt=6></p><table><thead><tr><th style=text-align:center>index</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th><th style=text-align:center>6</th><th style=text-align:center>7</th><th style=text-align:center>8</th><th style=text-align:center>9</th></tr></thead><tbody><tr><td style=text-align:center>fa</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>3</td><td style=text-align:center>3</td><td style=text-align:center>5</td><td style=text-align:center>7</td></tr></tbody></table><p>Tarjan求解LCA的过程就是这样，多看几遍流程就懂了，算法实现蛮容易的，就不写代码了</p><h2 id=倍增>倍增</h2><p>求LCA容易想到一个暴力方法就是，先将较深的顶点一步步跳到和较浅的顶点一样深度，判断他们是否相等，相等的话说明较浅的顶点就是他们的最近公共祖先，如果不相等的话，再一起一步步向上跳，直到相等为止。</p><p>倍增和这个暴力法的区别就是，倍增不是一步步跳的，它每次跳2^i步，比如1、 2、 4、 8……等。</p><p>但是现在有一个问题就是，我们怎么知道每一个顶点向上跳1、 2、 4……步到达的顶点是多少呢？所以我们要预处理每一个顶点向上跳1、 2、 4……步之后到达的顶点是什么。</p><p>预处理是用dp做的，假设fa[i][j]表示顶点i向上走2^j步之后到达的顶点。那很显然fa[i][0]就是自己的父亲。fa[i][1]就是向上跳了两步，是自己的爷爷。fa[i][2]向上跳了4步，到达了爷爷的爷爷。我们可以发现fa[i][1]=fa[fa[i][1-1]][1-1]，fa[i][2]=fa[fa[i][2-1]][2-1]。第一条等式是找自己的爷爷，相当于是父亲的父亲，第二条等式是爷爷的爷爷，所以先向上跳两步到爷爷，爷爷再向上跳两步到达爷爷的爷爷。</p><p>所以我们找出了状态转移方程为<strong>fa[i][j] = fa[fa[i][j-1]][j-1]</strong>，用dp很容易就预处理好。</p><p>用洛谷的板题来看看代码怎么写吧。</p><p><a href=https://www.luogu.org/problem/P3379>洛谷P3379</a></p><p><img src=lg3379.png alt=lg3379></p><pre><code class=language-c++>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair&lt;int, int&gt; P;
const int maxn = 5e5+5;
const ll mod = 1e9+7;

vector&lt;int&gt; son[maxn]; // 存储儿子顶点
// dep[i]表示顶点i的深度，n个顶点，m个询问，rt为树根，fa数组用来预处理顶点i向上跳2^j步之后的顶点
int dep[maxn], n, m, rt, fa[maxn][20];
int v[maxn]={0}; // 是否访问标记

// pre是父顶点，rt是当前顶点
void dfs(int pre, int rt)
{
    dep[rt] = dep[pre]+1; // 当前顶点的深度为父顶点加一
    fa[rt][0] = pre; // 当前顶点向上跳一步为父顶点
    v[rt] = 1; // 访问
    // dp预处理
    for(int i=1;i&lt;=19;i++)
        fa[rt][i] = fa[fa[rt][i-1]][i-1];
    // 继续dfs
    for(int i=0;i&lt;son[rt].size();i++)
        if(v[son[rt][i]]==0)
            dfs(rt, son[rt][i]);
}

// 求解LCA(a, b)
int lca(int a, int b)
{
    // 如果a较浅，则交换a， b的值
    if(dep[a] &lt; dep[b])
        swap(a, b);
    // 从2^19开始看看能不能向上跳（19是根据数据范围大小决定的）
    for(int i=19;i&gt;=0;i--)
    {
        // 如果当前深度差大于2^i的话，就可以把a向上跳
        if(dep[a]-dep[b] &gt;= (1&lt;&lt;i))
        {
            a = fa[a][i];
        }
    }
    // 判断当a和b同一个深度时是否为同一个顶点
    if(a==b)return a;
    // 一起向上跳
    for(int i=19;i&gt;=0;i--)
    {
        // 如果向上跳2^i不相等的话，就是还没到达公共祖先的时候就一起跳
        if(fa[a][i] != fa[b][i])
        {
            a = fa[a][i];
            b = fa[b][i];
        }
    }
    // 结束for循环的时候两个顶点还差1步就到达最近公共祖先了，所以返回fa[a][0]
    return fa[a][0];
}

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;rt);
    for(int i=1;i&lt;n;i++)
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        son[a].push_back(b);
        son[b].push_back(a);
    }
    memset(fa, 0, sizeof(fa));
    memset(dep, inf, sizeof(dep));
    v[0]=1;
    dep[0] = 0;
    dfs(0, rt);
    for(int i=1;i&lt;=m;i++)
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        printf(&quot;%d\n&quot;, lca(a, b));
    }
    return 0;
}
</code></pre><p>倍增还是蛮好理解的，不算很难。</p><h2 id=rmq>RMQ</h2><p>RMQ(Range Minimum/Maximum Query)，即区间最值查询，用来查询一段区间的最大值最小值信息，容易想到的是ST表、树状数组、线段树等数据结构。</p><p>LCA是在树上做操作，难免有一些麻烦，所以我们考虑能不能够把树用线性表示。答案是可以的，我们用DFS序将树转化为线性的。</p><p>所以将LCA问题转化为RMQ问题用到了DFS序和ST表。</p><h3 id=dfs序>DFS序</h3><p>DFS序就是对一颗树进行DFS之后得到的一串序列。</p><p>DFS序有两种：</p><ul><li>仅在第一次经过和最后退出时记录该顶点的序号</li><li>每一次经过该顶点都记录顶点的序号</li></ul><p>在这里我们选第二种DFS序，用下面这一颗树做例子。</p><p><img src=s.png alt=ss></p><p>得到的DFS序为<strong>1、 2、 4、 4、 2、 5、 8、 8、 5、 2、 1、 3、 6、 6、 3、 7、 9、 9、 7、 3、 1</strong>，跟着图看一遍就能看懂这个DFS序怎么来的了。</p><h3 id=st表>ST表</h3><p>ST表是一种O(nlogn)预处理O(1)查询的数据结构，其实ST表和倍增里面的fa数组类似，也是用dp来做预处理。</p><p>在这里我们维护的是最小值，所以我也用最小值来举例。</p><p>st[i][j]表示的是从i开始，长度为2^j这一段区间里面的最小值。那么如何状态转移呢？st[i][j] = min(st[i][j-1], st[i+(1&#171;(j-1)][j-1])。自己画个图看看是不是这么一回事。</p><p>假设我们要查询区间[l, r]的最小值要怎么做？区间的长度为r-l+1，我们要在st表中找两端区间能够覆盖住[l, r]，因为我们的st表表示的长度都是2^i那么长，那这一段区间找两段长度为k = log2(r-l+1)来进行覆盖。所以查询[l, r]的最小值就为min(st[l][k], st[r-(1&#171;k)+1][k])，这样就轻松的实现了O(1)查询。</p><p>放一个st表的板子</p><pre><code class=language-c++>int st[maxn][20];
void st_init()
{
    for(int i=1;i&lt;=n;i++) st[i][0]=a[i]; // 长度为1的区间最小值党委就为自身
    // 预处理从i开始，长度为2^j的区间
    for(int j=1;(1&lt;&lt;j)&lt;=n;j++)
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)
            st[i][j]=max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);
}

int query(int l,int r)
{
    int k=log2(r-l+1);
    return min(st[l][k],st[r-(1&lt;&lt;k)+1][k]);
}
</code></pre><h3 id=lca转rmq>LCA转RMQ</h3><p>现在我们知道如何用DFS序将树转化为线性结构，如何用ST表来查询区间最小值。那如何将LCA问题转化为RMQ问题呢？我们的ST表是根据得到的DFS序来做预处理，存储的是从i开始，长度为2^j这一段区间里面深度最小的顶点在DFS序中的位置。</p><p>所以我们还需要一个记录深度的dep数组，一个记录DFS序的vis数组，一个记录顶点i第一次在vis数组出现的位置的id数组。</p><p>查询LCA(a, b)时就在DFS序中，找a和b第一次出现的位置之间的这一段区间里面深度最小的顶点，该顶点就是a和b的最近公共祖先。</p><p>同样用刚刚洛谷的那一个板题来看看代码怎么写吧。</p><pre><code class=language-c++>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair&lt;int, int&gt; P;
const int maxn = 5e5+5;
const ll mod = 1e9+7;

vector&lt;int&gt; g[maxn]; // 存图
// dep记录DFS序中每一个顶点的深度， vis记录DFS序， id记录顶点i第一次在DFS序中的位置， st表
int dep[maxn&lt;&lt;1]={0}, vis[maxn&lt;&lt;1]={0}, id[maxn]={0}, st[maxn&lt;&lt;1][25];
// dfs序计数用，看代码能理解
int dfs_c=1;

// 父顶点为pre， 当前顶点为now， 当前深度为d
void dfs(int pre, int now, int d)
{
    id[now] =  dfs_c; // now顶点在DFS序中第一次出现的位置是dfs_c
    dep[dfs_c] = d; // 记录now的深度
    vis[dfs_c++] = now; // DFS序中第dfs_c个顶点是now，同时将dfs_c加一
    // 遍历now的儿子
    for(int i=0;i&lt;g[now].size();i++)
    {
        // 因为存图是存双向变，所以这里要做一个判断
        if(g[now][i]!=pre)
        {
            // dfs自己的儿子顶点
            dfs(now, g[now][i], d+1);
            // 回退到now时也要在DFS序中记录，同时dep数组也要记录深度，但是id数组就不需要更新了，因为这里不是 第一次访问now顶点了
            vis[dfs_c] = now;
            dep[dfs_c++] = d;
        }
    }
}

// 预处理st表
void getSt(int n)
{
    for(int i=1;i&lt;=n;i++)
        st[i][0] = i;
    for(int j=1; (1&lt;&lt;j)&lt;=n; j++)
    {
        for(int i=1;i+(1&lt;&lt;j)&lt;=n; i++)
        {
            int a = st[i][j-1], b = st[i+(1&lt;&lt;(j-1))][j-1];
            // 注意这里有一点点不同，st表要记录深度最小的顶点在DFS序中的位置。
            if(dep[a] &lt; dep[b])
                st[i][j] = a;
            else st[i][j] = b;
        }
    }
}

// 查询DFS序中区间[l, r]深度最小的顶点在DFS序中的位置
int query(int l, int r)
{
    int k = log2(r-l+1);
    int a = st[l][k];
    int b = st[r-(1&lt;&lt;k)+1][k];
    // 返回深度较小的那一个顶点在DFS序中的位置
    if(dep[a]&lt;dep[b])return a;
    else return b;
}

// 求LCA(a, b)
int lca(int a, int b)
{
    int x, y;
    // 查找a和b在DFS序中第一次出现的位置
    x = id[a], y = id[b];
    // 小的那一个作为左边界， 大的作为右边界
    // 返回具体的顶点序号
    if(x&gt;y)return vis[query(y, x)];
    else return vis[query(x, y)];
}

// 检查用的
void check(int n)
{
    for(int i=1;i&lt;=dfs_c;i++)cout&lt;&lt;dep[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;&quot;\n\n&quot;;
    for(int i=1;i&lt;=dfs_c;i++)cout&lt;&lt;vis[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;&quot;\n\n&quot;;
    for(int i=1;i&lt;=n;i++)cout&lt;&lt;id[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;&quot;\n\n&quot;;
}

int main()
{
    int n, m, rt;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;rt);
    for(int i=1;i&lt;n;i++)
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs(0, rt, 1);
    getSt(dfs_c);
    //check(n);
    for(int i=1;i&lt;=m;i++)
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        printf(&quot;%d\n&quot;, lca(a, b));
    }
    return 0;
}
</code></pre><h2 id=end>END</h2><p>LCA问题还算是蛮常见的吧，溜了溜了～</p></article><div class=my-4><a href=/tags/algorithm/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#Algorithm</a></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">上一页</span>
<a href=/posts/tarjan/ class=block>Tarjan求解强连通分量、割点、桥</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/posts/persistent-seg-tree/ class=block>可持久化线段树(主席树)</a></div></div><div id=valine-comments class=mt-4></div><script defer src=https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js integrity=sha384-e0+DNUCJo75aOAzHQbFWYBCM9/S4f0BhRJXvEgbE3mMS85RM20MSSGStHuNdY2QK crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){new Valine({el:"#valine-comments",appId:"zOEvCRaHczqQkvn7g5bk2d9c-gzGzoHsz",appKey:"JJQvXVH4XIDyjJaIK2HWeTY3"})})</script></div><div class=col-span-2><div class="bg-primary-bg
prose sticky top-16 z-10 hidden px-6 py-4 lg:block"><h3>本页内容</h3></div><div class="sticky-toc hidden px-6 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#tarjan>Tarjan</a></li><li><a href=#倍增>倍增</a></li><li><a href=#rmq>RMQ</a><ul><li><a href=#dfs序>DFS序</a></li><li><a href=#st表>ST表</a></li><li><a href=#lca转rmq>LCA转RMQ</a></li></ul></li><li><a href=#end>END</a></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div><div class="bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"><h3>相关</h3><a href=/posts/persistent-seg-tree/ class=no-underline>可持久化线段树(主席树)</a><br><a href=/posts/shortest-path/ class=no-underline>图论——最短路径</a><br><a href=/posts/seg-tree/ class=no-underline>线段树基础</a><br></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2019 - 2023 <a href=https://github.com/Elitedj>Elitedj</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>