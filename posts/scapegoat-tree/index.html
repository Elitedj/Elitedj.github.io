<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>替罪羊树 | Elitedj's Blog</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script>
<link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.8c77c7521b1f95ec2031c2a79f5c6a698aa4a0dba5ba649dfbc7f73994cddf3f494be6aac7e5724f35cbf72cfde09703.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/avatar_hubecf9d80b8b876872272a68886c75e90_327995_180x180_fill_box_center_3.png><meta name=description content="Elitedj's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"替罪羊树","item":"/posts/scapegoat-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/scapegoat-tree/"},"headline":"替罪羊树 | Elitedj\u0027s Blog","datePublished":"2020-09-08T09:01:24+00:00","dateModified":"2020-09-08T09:01:24+00:00","wordCount":2463,"publisher":{"@type":"Person","name":"Elitedj","logo":{"@type":"ImageObject","url":"/images/avatar.png"}},"description":"Elitedj\u0027s Blog"}</script><meta property="og:title" content="替罪羊树 | Elitedj's Blog"><meta property="og:type" content="article"><meta property="og:image" content="/images/avatar.png"><meta property="og:url" content="/posts/scapegoat-tree/"><meta property="og:description" content><meta property="og:locale" content="zh"><meta property="og:site_name" content="Elitedj's Blog"><meta property="article:published_time" content="2020-09-08T09:01:24+00:00"><meta property="article:modified_time" content="2020-09-08T09:01:24+00:00"><meta property="article:section" content="posts"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Data Structure"><meta property="og:see_also" content="/posts/persistent-set-union/"><meta property="og:see_also" content="/posts/persistent-array/"><meta property="og:see_also" content="/posts/trie/"><meta property="og:see_also" content="/posts/persistent-seg-tree/"><meta property="og:see_also" content="/posts/seg-tree/"><meta property="og:see_also" content="/posts/max-min-representation/"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Elitedj's Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>替罪羊树</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2020-09-08</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>5分钟阅读时长</span></div><div class="me-6 my-2"><i class="fas fa-folder me-1"></i>
<a href=/categories/algorithm/ class=hover:text-eureka>Algorithm</a>
<span>,</span>
<a href=/categories/data-structure/ class=hover:text-eureka>Data Structure</a></div></div><p><img src=fengmian.jpg alt=fengmian></p><h1 id=替罪羊树>替罪羊树？</h1><p>替罪羊树是一种平衡二叉搜索树，在维护树的平衡时，不需要进行旋转操作，而是通过一种非常暴力的重构来保证树的平衡。</p><h1 id=替罪羊树-1>替罪羊树</h1><h2 id=参数定义>参数定义</h2><p>树结点的定义如下，需要记录左右子树的序号、当前结点的值、当前子树的大小、当前子树的真实大小以及当前结点是否存在。</p><p>当前子树的真实大小是指去掉被删除结点的大小，因为替罪羊树采用懒删除的思想，删除节点时不是真的马上删除，而是在下一次重构时才真的把结点删除，所以对于每一个结点来说，用<code>exist</code>标记该结点是否被删除。</p><pre><code class=language-c++>struct node {
	int l, r, val;
	int size, fact;
	int exist;
}tree[maxn];

int cnt, root;
</code></pre><h2 id=插入>插入</h2><p>插入操作非常的简单，与二叉搜索树没什么差别。其中<code>insert()</code>中的<code>check()</code>是检查是否需要重构来保证树的平衡的，之后会讲到，这里可以先忽略。</p><pre><code class=language-c++>// 新建结点
void newnode(int &amp;now, int val) {
	now = ++cnt;
	tree[now].val = val;
	tree[now].size = tree[now].fact = 1;
	tree[now].exist = 1;
}

// 插入
void insert(int &amp;now, int val) {
	if (!now) {
		newnode(now, val);
		check(root, now);
		return;
	}
	tree[now].size++;
	tree[now].fact++;
	if (val &lt; tree[now].val) insert(tree[now].l, val);
	else insert(tree[now].r, val);
}
</code></pre><h2 id=删除>删除</h2><p>删除操作也非常的简单，找到该结点并且将<code>exist</code>标记改为0即可，同时也需要<code>check()</code>一下是否需要重构。</p><pre><code class=language-c++>// 删除
void del(int now, int val) {
	if (tree[now].exist &amp;&amp; tree[now].val == val) {
		tree[now].exist = 0;
		tree[now].fact--;
		check(root, now);
		return;
	}
	tree[now].fact--;
	if (val &lt; tree[now].val) del(tree[now].l, val);
	else del(tree[now].r, val);
}
</code></pre><h2 id=重构>重构</h2><h3 id=判断是否需要重构>判断是否需要重构</h3><p>因为只有插入和删除操作会影响树的高度，所以只需要在插入和删除的函数里面调用<code>check()</code>函数来判断是否需要重构。而插入和删除操作只对树的一条链路有影响，所以重构时，我们在该链路上寻找需要重构的子树。</p><p>那么我们是从下往上找好呢还是从上往下找好呢？很显然是从上往下找好，因为从下往上找可能需要多次重构，而从上往下找到一颗子树需要重构那么剩下的都会在这一次重构中完成。</p><p>所以也可以看到我们在调用<code>check()</code>函数时，传递的参数是从root到now结点，即从上往下找。</p><p><code>check()</code>函数非常的简单，只是一层简单的封装。</p><pre><code class=language-c++>// 检查是否需要重构
void check(int &amp;now, int end) {
	if (now == end) return;
	if (imbalence(now)) {
		rebuild(now);
		update(root, now);
		return;
	}
	if (tree[end].val &lt; tree[now].val) check(tree[now].l, end);
	else check(tree[now].r, end);
}
</code></pre><h3 id=判断是否平衡>判断是否平衡</h3><p>我们如何判断替罪羊树是否平衡呢？</p><p>我们先定义一个平衡因子<code>alpha</code>，<code>alpha</code>的值必需取<code>0.5~1.0</code>之间，我这里取<code>0.75</code>，当满足下面两个条件的一个就需要重构了。</p><ul><li>当子树的左子树或者右子树的size大于子树的<code>size * alpha</code>时</li><li>当子树被删除的结点数大于子树的<code>size * 0.3</code>的时，既<code>tree[now].size - tree[now].fact > tree[now].size * 0.3</code></li></ul><p>那么判断树是否平衡的函数也非常的好写了</p><pre><code class=language-c++>const double alpha = 0.75;

// 判断是否不平衡
bool imbalence(int now) {
	if (max(tree[tree[now].l].size, tree[tree[now].r].size) &gt; tree[now].size * alpha
			|| tree[now].size - tree[now].fact &gt; tree[now].size * 0.3)
		return true;
	return false;
}
</code></pre><h3 id=重构子树>重构子树</h3><p>替罪羊树是通过一种非常暴力的方式来进行重构的。</p><p>首先对需要重构的子树进行中序遍历，将未删除的结点加到vector里面，然后通过分治的方式，把中序遍历的结果“提”起来变成一颗树，就像下面这张图一样。</p><p><img src=lift.jpg alt=lift></p><pre><code class=language-c++>vector&lt;int&gt; v;	// 记录中序遍历的结果

// 对now为根的子树做中序遍历
void inoder(int now) {
	if (!now) return;
	inoder(tree[now].l);
	if (tree[now].exist) v.push_back(now);
	inoder(tree[now].r);
}

// 对中序遍历的结果重构
void lift(int l, int r, int &amp;now) {
	if (l == r) {
		now = v[l];
		tree[now].l = tree[now].r = 0;
		tree[now].size = tree[now].fact = 1;
		return;
	}
	int mid = (l + r) &gt;&gt; 1;
    // 出现重复值时，要将重复值挂在右子树，所以需要while找最左边的重复值
	while (l &lt; mid &amp;&amp; tree[v[mid]].val == tree[v[mid-1]].val) mid--;
	now = v[mid];
    // 左子树可能为空，所以需要判断一下
	if (l &lt; mid) lift(l, mid-1, tree[now].l);
	else tree[now].l = 0;
	lift(mid+1, r, tree[now].r);
	tree[now].size = tree[tree[now].l].size + tree[tree[now].r].size + 1;
	tree[now].fact = tree[tree[now].l].fact + tree[tree[now].r].fact + 1; 
}

// 对以now为根的子树重构
void rebuild(int &amp;now) {
	v.clear();
	inoder(now);
    // 子树全被删除了，直接将该结点置空就好
	if (v.empty()) {
		now = 0;
		return;
	}
	lift(0, v.size()-1, now);
}
</code></pre><h3 id=更新信息>更新信息</h3><p>重构子树后，需要对链路上未重构的结点的信息进行更新，操作也很简单，通过递归回溯的方式更新。</p><pre><code class=language-c++>// 重构完后更新根到now链路上结点的信息
void update(int now, int end) {
	if (!now) return;
	if (tree[end].val &lt; tree[now].val) update(tree[now].l, end);
	else update(tree[now].r, end);
	tree[now].size = tree[tree[now].l].size + tree[tree[now].r].size + 1;
}
</code></pre><h2 id=获取值x的排名>获取值x的排名</h2><p>排名的定义是值小于x的数的个数+1，在统计<code>rank</code>的值时，往左子树走时，是无贡献的，只有往右子树走时，才有左子树和根节点的贡献。</p><pre><code class=language-c++>// 根据值获得排名，即比当前数小的个数+1
int getrank(int val) {
	int now = root, rank = 1;
	while(now) {
		if (val &lt;= tree[now].val)
			now = tree[now].l;
		else {
            // 往右子树走，统计小于x的值的个数
			rank += tree[now].exist + tree[tree[now].l].fact;
			now = tree[now].r;
		}
	}
	return rank;
}
</code></pre><h2 id=根据排名rank获取值val>根据排名rank获取值val</h2><p>与主席树求第k大时也很像。</p><pre><code class=language-c++>// 根据排名获得值
int getnum(int rank) {
	int now = root;
	while (now) {
		if (tree[now].exist &amp;&amp; tree[tree[now].l].fact + tree[now].exist == rank)
			break;
		else if(tree[tree[now].l].fact &gt;= rank)
			now = tree[now].l;
		else {
			rank -= tree[tree[now].l].fact + tree[now].exist;
			now = tree[now].r;
		}
	}
	return tree[now].val;
}
</code></pre><h2 id=x的前驱>x的前驱</h2><pre><code class=language-c++>// 找x的前驱，即小于x且最大的数
int getpre(int x) {
	return getnum(getrank(x) - 1);
}
</code></pre><h2 id=x的后继>x的后继</h2><pre><code class=language-c++>// 找x的后继，即大于x且最小的数
int getnext(int x) {
	return getnum(getrank(x + 1));
    // 注意这里为什么不是下面的写法
    // return getnum(getrank(x) + 1);
    // 这样写在出现重复数字时会出现错误，而getrank(x+1)是把所有x都包含进去了，不会出现错误。
}
</code></pre><h1 id=洛谷p3369>洛谷P3369</h1><p><a href=https://www.luogu.com.cn/problem/P3369>洛谷P3369</a>是平衡树的模板题</p><p><img src=p3369.png alt=p3369></p><pre><code class=language-c++>// 样例输入
10
1 106465
4 1
1 317721
1 460929
1 644985
1 84185
1 89851
6 81968
1 492737
5 493598

// 样例输出
106465
84185
492737
</code></pre><pre><code class=language-c++>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define IO ios::sync_with_stdio(0)
#define DEBUG(x) cout&lt;&lt;&quot;---&gt;&quot;&lt;&lt;(x)&lt;&lt;endl;
typedef pair&lt;int, int&gt; P;
const ll mod = 1e9+7;
const double eps = 1e-9;
const double PI = acos(-1);
const int maxn = 2e5+5;


struct node {
	int l, r, val;
	int size, fact;
	int exist;
}tree[maxn];

int cnt, root;
const double alpha = 0.75;	// 平衡因子
vector&lt;int&gt; v;	// 记录中序遍历的结果

// 新建结点
void newnode(int &amp;now, int val) {
	now = ++cnt;
	tree[now].val = val;
	tree[now].size = tree[now].fact = 1;
	tree[now].exist = 1;
}

// 判断是否不平衡
bool imbalence(int now) {
	if (max(tree[tree[now].l].size, tree[tree[now].r].size) &gt; tree[now].size * alpha
			|| tree[now].size - tree[now].fact &gt; tree[now].size * 0.3)
		return true;
	return false;
}

// 对now为根的子树做中序遍历
void inorder(int now) {
	if (!now) return;
	inorder(tree[now].l);
	if (tree[now].exist) v.push_back(now);
	inorder(tree[now].r);
}

// 对中序遍历的结果重构
void lift(int l, int r, int &amp;now) {
	if (l == r) {
		now = v[l];
		tree[now].l = tree[now].r = 0;
		tree[now].size = tree[now].fact = 1;
		return;
	}
	int mid = (l + r) &gt;&gt; 1;
	while (l &lt; mid &amp;&amp; tree[v[mid]].val == tree[v[mid-1]].val) mid--;
	now = v[mid];
	if (l &lt; mid) lift(l, mid-1, tree[now].l);
	else tree[now].l = 0;
	lift(mid+1, r, tree[now].r);
	tree[now].size = tree[tree[now].l].size + tree[tree[now].r].size + 1;
	tree[now].fact = tree[tree[now].l].fact + tree[tree[now].r].fact + 1; 
}

// 对以now为根的子树重构
void rebuild(int &amp;now) {
	v.clear();
	inorder(now);
	if (v.empty()) {
		now = 0;
		return;
	}
	lift(0, v.size()-1, now);
}

// 重构完后更新根到now链路上结点的信息
void update(int now, int end) {
	if (!now) return;
	if (tree[end].val &lt; tree[now].val) update(tree[now].l, end);
	else update(tree[now].r, end);
	tree[now].size = tree[tree[now].l].size + tree[tree[now].r].size + 1;
}

// 检查是否需要重构
void check(int &amp;now, int end) {
	if (now == end) return;
	if (imbalence(now)) {
		rebuild(now);
		update(root, now);
		return;
	}
	if (tree[end].val &lt; tree[now].val) check(tree[now].l, end);
	else check(tree[now].r, end);
}

// 插入
void insert(int &amp;now, int val) {
	if (!now) {
		newnode(now, val);
		check(root, now);
		return;
	}
	tree[now].size++;
	tree[now].fact++;
	if (val &lt; tree[now].val) insert(tree[now].l, val);
	else insert(tree[now].r, val);
}

// 删除
void del(int now, int val) {
	if (tree[now].exist &amp;&amp; tree[now].val == val) {
		tree[now].exist = 0;
		tree[now].fact--;
		check(root, now);
		return;
	}
	tree[now].fact--;
	if (val &lt; tree[now].val) del(tree[now].l, val);
	else del(tree[now].r, val);
}

// 根据值获得排名，即比当前数小的个数+1
int getrank(int val) {
	int now = root, rank = 1;
	while(now) {
		if (val &lt;= tree[now].val)
			now = tree[now].l;
		else {
			rank += tree[now].exist + tree[tree[now].l].fact;
			now = tree[now].r;
		}
	}
	return rank;
}

// 根据排名获得值
int getnum(int rank) {
	int now = root;
	while (now) {
		if (tree[now].exist &amp;&amp; tree[tree[now].l].fact + tree[now].exist == rank)
			break;
		else if(tree[tree[now].l].fact &gt;= rank)
			now = tree[now].l;
		else {
			rank -= tree[tree[now].l].fact + tree[now].exist;
			now = tree[now].r;
		}
	}
	return tree[now].val;
}

// 找x的前驱，即小于x且最大的数
int getpre(int x) {
	return getnum(getrank(x) - 1);
}

// 找x的后继，即大于x且最小的数
int getnext(int x) {
	return getnum(getrank(x + 1));
}

int main() {
	int t;
	scanf(&quot;%d&quot;, &amp;t);
	while (t--) {
		int opt, x;
		scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
		if (opt == 1) insert(root, x);
		else if(opt == 2) del(root, x);
		else if(opt == 3) printf(&quot;%d\n&quot;, getrank(x));
		else if(opt == 4) printf(&quot;%d\n&quot;, getnum(x));
		else if(opt == 5) printf(&quot;%d\n&quot;, getpre(x));
		else printf(&quot;%d\n&quot;, getnext(x));
	}
	return 0;
}
</code></pre></article><div class=my-4><a href=/tags/algorithm/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#Algorithm</a>
<a href=/tags/data-structure/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#Data Structure</a></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">上一页</span>
<a href=/posts/modui/ class=block>莫队算法</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/posts/persistent-set-union/ class=block>可持久化并查集</a></div></div><div id=valine-comments class=mt-4></div><script defer src=https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js integrity=sha384-e0+DNUCJo75aOAzHQbFWYBCM9/S4f0BhRJXvEgbE3mMS85RM20MSSGStHuNdY2QK crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){new Valine({el:"#valine-comments",appId:"zOEvCRaHczqQkvn7g5bk2d9c-gzGzoHsz",appKey:"JJQvXVH4XIDyjJaIK2HWeTY3"})})</script></div><div class=col-span-2><div class="bg-primary-bg
prose sticky top-16 z-10 hidden px-6 py-4 lg:block"><h3>本页内容</h3></div><div class="sticky-toc hidden px-6 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#参数定义>参数定义</a></li><li><a href=#插入>插入</a></li><li><a href=#删除>删除</a></li><li><a href=#重构>重构</a><ul><li><a href=#判断是否需要重构>判断是否需要重构</a></li><li><a href=#判断是否平衡>判断是否平衡</a></li><li><a href=#重构子树>重构子树</a></li><li><a href=#更新信息>更新信息</a></li></ul></li><li><a href=#获取值x的排名>获取值x的排名</a></li><li><a href=#根据排名rank获取值val>根据排名rank获取值val</a></li><li><a href=#x的前驱>x的前驱</a></li><li><a href=#x的后继>x的后继</a></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div><div class="bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"><h3>相关</h3><a href=/posts/persistent-set-union/ class=no-underline>可持久化并查集</a><br><a href=/posts/persistent-array/ class=no-underline>可持久化数组</a><br><a href=/posts/trie/ class=no-underline>字典树(Trie)</a><br><a href=/posts/persistent-seg-tree/ class=no-underline>可持久化线段树(主席树)</a><br><a href=/posts/seg-tree/ class=no-underline>线段树基础</a><br><a href=/posts/max-min-representation/ class=no-underline>最大最小表示法</a><br></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2019 - 2023 <a href=https://github.com/Elitedj>Elitedj</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>