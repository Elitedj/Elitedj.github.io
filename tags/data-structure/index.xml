<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Structure on Elitedj's Blog</title><link>/tags/data-structure/</link><description>Recent content in Data Structure on Elitedj's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy; 2019 - 2023 &lt;a href="https://github.com/Elitedj">Elitedj&lt;/a></copyright><lastBuildDate>Sun, 30 Apr 2023 16:13:11 +0800</lastBuildDate><atom:link href="/tags/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>从2-4树到红黑树</title><link>/posts/redblacktree/</link><pubDate>Sun, 30 Apr 2023 16:13:11 +0800</pubDate><guid>/posts/redblacktree/</guid><description>对于一般的二叉搜索树来说，查找、插入、删除的平均时间复杂度都是$O(logN)$，但最坏情况是$O(N)$。而平衡树可以保证这三种方法的复杂度都是$O</description></item><item><title>Treap</title><link>/posts/treap/</link><pubDate>Tue, 15 Sep 2020 10:55:37 +0000</pubDate><guid>/posts/treap/</guid><description/></item><item><title>替罪羊树</title><link>/posts/scapegoat-tree/</link><pubDate>Tue, 08 Sep 2020 09:01:24 +0000</pubDate><guid>/posts/scapegoat-tree/</guid><description/></item><item><title>可持久化并查集</title><link>/posts/persistent-set-union/</link><pubDate>Mon, 07 Sep 2020 09:16:05 +0000</pubDate><guid>/posts/persistent-set-union/</guid><description/></item><item><title>可持久化数组</title><link>/posts/persistent-array/</link><pubDate>Sun, 06 Sep 2020 19:39:56 +0000</pubDate><guid>/posts/persistent-array/</guid><description/></item><item><title>字典树(Trie)</title><link>/posts/trie/</link><pubDate>Tue, 04 Feb 2020 19:35:29 +0000</pubDate><guid>/posts/trie/</guid><description/></item><item><title>可持久化线段树(主席树)</title><link>/posts/persistent-seg-tree/</link><pubDate>Thu, 29 Aug 2019 09:39:11 +0000</pubDate><guid>/posts/persistent-seg-tree/</guid><description/></item><item><title>线段树基础</title><link>/posts/seg-tree/</link><pubDate>Thu, 25 Jul 2019 20:30:10 +0000</pubDate><guid>/posts/seg-tree/</guid><description/></item></channel></rss>